---
title: Getting Started
description: Install tx and run your first agent loop
---

Get up and running with tx in minutes. tx provides four interfaces -- pick whichever fits your workflow.

| Interface | Package | Best For |
|-----------|---------|----------|
| CLI | `@jamesaphoenix/tx-cli` | Shell scripts, human operators |
| TypeScript SDK | `@jamesaphoenix/tx-agent-sdk` | Custom agents in Node/Bun |
| MCP Server | `@jamesaphoenix/tx-mcp-server` | Claude, Cursor, AI IDEs |
| REST API | `@jamesaphoenix/tx-api-server` | Language-agnostic HTTP clients |

## Installation

<Tabs groupId="interface" persist items={["CLI", "TypeScript SDK", "MCP", "REST API"]}>
<Tab value="CLI">

Install the CLI globally:

```bash
npm install -g @jamesaphoenix/tx-cli
```

Or with your preferred package manager:

```bash
# pnpm
pnpm add -g @jamesaphoenix/tx-cli

# bun
bun add -g @jamesaphoenix/tx-cli
```

</Tab>
<Tab value="TypeScript SDK">

Add the Agent SDK to your project:

```bash
npm install @jamesaphoenix/tx-agent-sdk
```

The SDK supports two modes:
- **HTTP mode** -- connects to the API server (recommended for distributed agents)
- **Direct mode** -- reads SQLite directly (for local, single-process agents)

</Tab>
<Tab value="MCP">

Add the MCP server to your Claude Desktop or IDE configuration:

```json
{
  "mcpServers": {
    "tx": {
      "command": "npx",
      "args": ["@jamesaphoenix/tx-mcp-server"]
    }
  }
}
```

No separate API server is needed -- the MCP server accesses the SQLite database directly.

</Tab>
<Tab value="REST API">

Launch the API server:

```bash
npx @jamesaphoenix/tx-api-server
```

Or with bun:

```bash
bunx @jamesaphoenix/tx-api-server
```

The server runs on `http://localhost:3456` by default. Configure with flags or environment variables:

```bash
# Custom port
npx @jamesaphoenix/tx-api-server --port 8080

# Custom database path
npx @jamesaphoenix/tx-api-server --db /path/to/tasks.db

# Environment variables
TX_API_PORT=8080 TX_DB_PATH=./my.db npx @jamesaphoenix/tx-api-server
```

</Tab>
</Tabs>

## Initialize Your Project

Navigate to your project directory and initialize tx:

```bash
cd your-project
tx init
```

Optional agent onboarding scaffolds:

```bash
tx init --claude            # CLAUDE.md + .claude/skills
tx init --codex             # AGENTS.md + .codex/agents
tx init --claude --codex    # scaffold both
tx init --watchdog          # watchdog scripts + launcher + service templates (opt-in)
tx init --watchdog --watchdog-runtime codex
```

This creates a `.tx/` directory:

```
.tx/
├── tasks.db           # SQLite database (gitignored)
├── tasks.jsonl        # Git-tracked task history
├── learnings.jsonl    # Git-tracked learnings
└── runs.jsonl         # Git-tracked run history
```

## Watchdog Onboarding (Opt-In)

Watchdog onboarding is explicit opt-in and default-off. `tx init` alone does not enable detached supervision.

Use watchdog when you need:
- Long-running unattended RALPH loops
- Automatic restart and health checks for Codex/Claude loops
- Automatic reconciliation of stale runs and orphaned active tasks

Skip watchdog when you only run short, interactive sessions.

Enable watchdog during init:

```bash
tx init --watchdog --watchdog-runtime auto
```

Runtime mode behavior:

| Mode | Behavior |
|------|----------|
| `auto` | Enables only runtimes available in `PATH`; if none are available, scaffolds assets with `WATCHDOG_ENABLED=0` |
| `codex` | Requires `codex` CLI in `PATH` or exits with actionable error |
| `claude` | Requires `claude` CLI in `PATH` or exits with actionable error |
| `both` | Requires both CLIs in `PATH` or exits with actionable error |

Watchdog scaffolding adds:

```
scripts/ralph-watchdog.sh
scripts/ralph-hourly-supervisor.sh
scripts/watchdog-launcher.sh
.tx/watchdog.env
ops/watchdog/com.tx.ralph-watchdog.plist
ops/watchdog/tx-ralph-watchdog.service
```

Initial rollout check:

```bash
./scripts/watchdog-launcher.sh start
./scripts/watchdog-launcher.sh status
tail -n 50 .tx/ralph-watchdog.log
```

For detached service setup (`launchd`/`systemd`), rollback, stale PID cleanup, and troubleshooting, see:
- **[Watchdog Runbook](/docs/watchdog-runbook)**

## Quick Start

<Tabs groupId="interface" persist items={["CLI", "TypeScript SDK", "MCP", "REST API"]}>
<Tab value="CLI">

```bash
# Create a task
tx add "Implement user authentication"

# See what's ready to work on
tx ready

# Complete a task (unblocks dependents automatically)
tx done tx-abc123

# Add a dependency: tx-b waits for tx-a
tx block tx-b tx-a
```

</Tab>
<Tab value="TypeScript SDK">

```typescript
import { TxClient } from '@jamesaphoenix/tx-agent-sdk'

// HTTP mode (requires API server running)
const tx = new TxClient({ apiUrl: 'http://localhost:3456' })

// Or direct SQLite mode (no server needed)
// const tx = new TxClient({ dbPath: '.tx/tasks.db' })

// Create a task
const task = await tx.tasks.create({ title: 'Implement auth' })

// Get ready tasks
const ready = await tx.tasks.ready({ limit: 5 })

// Complete a task
await tx.tasks.done(ready[0].id)
```

</Tab>
<Tab value="MCP">

Once configured, your AI assistant has access to these tools:

| Tool | Description |
|------|-------------|
| `tx_add` | Create a task |
| `tx_ready` | List unblocked tasks |
| `tx_done` | Complete a task |
| `tx_block` | Add a dependency |
| `tx_show` | View task details |
| `tx_context` | Get relevant learnings |

Example prompt: *"Use tx_ready to find the highest priority task, then work on it and mark it done with tx_done."*

</Tab>
<Tab value="REST API">

```bash
# Create a task
curl -X POST http://localhost:3456/tasks \
  -H "Content-Type: application/json" \
  -d '{"title": "Implement auth"}'

# List ready tasks
curl http://localhost:3456/tasks/ready?limit=5

# Complete a task
curl -X POST http://localhost:3456/tasks/tx-abc123/done
```

</Tab>
</Tabs>

## Launching the API Server

The Agent SDK (HTTP mode) and REST API interface require the API server to be running. The CLI and MCP server access SQLite directly and do not need it.

```bash
# Start the API server
npx @jamesaphoenix/tx-api-server

# Or with bun
bunx @jamesaphoenix/tx-api-server
```

The server binds to `http://localhost:3456` by default. Available options:

| Flag | Env Variable | Default | Description |
|------|-------------|---------|-------------|
| `--port`, `-p` | `TX_API_PORT` | `3456` | Port to listen on |
| `--host` | `TX_API_HOST` | `127.0.0.1` | Hostname to bind to |
| `--db` | `TX_DB_PATH` | `.tx/tasks.db` | Path to SQLite database |
| -- | `TX_API_KEY` | -- | API key for authentication (optional) |

## Your First Agent Loop

The simplest agent loop pulls tasks one at a time:

```bash
#!/bin/bash
AGENT_CMD=${AGENT_CMD:-codex}  # or: claude
while true; do
  # Get highest priority ready task
  TASK=$(tx ready --json --limit 1 | jq -r '.[0].id // empty')

  # Exit if no ready tasks
  [ -z "$TASK" ] && break

  # Let your agent work on it
  "$AGENT_CMD" "Your task is $TASK. Run 'tx show $TASK' for details. When done, run 'tx done $TASK'"
done

echo "All tasks complete!"
```

## Store and Retrieve Learnings

As you work, capture knowledge that should persist:

```bash
# Store a learning
tx learning:add "Use bcrypt for password hashing, not SHA256"
tx learning:add "The auth service requires Redis for session storage"

# Search learnings
tx learning:search "authentication"

# Get context for a specific task (relevant learnings auto-selected)
tx context tx-abc123
```

## Sync with Git

tx stores data in SQLite for speed, but syncs to JSONL for git:

```bash
# Export to git-trackable files
tx sync export

# Import from JSONL (e.g., after git pull)
tx sync import
```

Add to your workflow:

```bash
# Before committing
tx sync export && git add .tx/*.jsonl

# After pulling
git pull && tx sync import
```

## Example Orchestration Patterns

### Parallel Agents

Run multiple agents pulling from the same queue:

```bash
AGENT_CMD=${AGENT_CMD:-codex}  # or: claude
for i in {1..5}; do
  (while task=$(tx ready --json --limit 1 | jq -r '.[0].id // empty'); do
    "$AGENT_CMD" "Complete $task" && tx done $task
  done) &
done
wait
```

### Human-in-Loop

Agent proposes, human approves:

```bash
AGENT_CMD=${AGENT_CMD:-codex}  # or: claude
task=$(tx ready --json --limit 1 | jq -r '.[0].id')
"$AGENT_CMD" "Plan implementation for $task" > plan.md
echo "Review plan.md, then press Enter to continue..."
read
"$AGENT_CMD" "Execute plan.md"
tx done $task
```

## Project Structure

```
your-project/
├── .tx/
│   ├── tasks.db           # SQLite (gitignored)
│   ├── tasks.jsonl        # Tasks (git-tracked)
│   ├── learnings.jsonl    # Learnings (git-tracked)
│   └── runs.jsonl         # Run history (git-tracked)
├── CLAUDE.md              # Claude instructions (optional)
├── AGENTS.md              # Codex instructions (optional)
├── .claude/               # Claude skills/hooks (optional)
├── .codex/agents/         # Codex agent profiles (optional)
└── ...your code
```

## Next Steps

You now have tx running. Keep moving in this order so each step builds on the last one:

1. **[Primitives](/docs/primitives)** -- learn the core building blocks (`ready`, `done`, `block`, `context`, `sync`).
2. **[Headful Experience](/docs/headful)** -- apply the same primitives visually with dashboard workflows.
3. **[Watchdog Runbook](/docs/watchdog-runbook)** -- final, advanced step for detached supervision and recovery.

Interface-specific deep dives:

- **[Agent SDK](/docs/agent-sdk)** -- build your own TypeScript agents.
- **[tx ready](/docs/primitives/ready)** -- readiness detection details.
- **[tx context](/docs/primitives/context)** -- contextual learning retrieval.
- **[tx sync](/docs/primitives/sync)** -- git synchronization behavior.

## Quick Reference

```bash
# Tasks
tx add <title>              # Create task
tx ready                    # List unblocked tasks
tx done <id>                # Complete task
tx block <id> <blocker>     # Add dependency
tx tree <id>                # Show hierarchy
tx show <id>                # View task details

# Memory
tx learning:add <content>   # Store learning
tx learning:search <query>  # Find learnings
tx context <task-id>        # Get relevant context

# Sync
tx sync export              # SQLite → JSONL
tx sync import              # JSONL → SQLite

# API Server
npx @jamesaphoenix/tx-api-server   # Start REST API
```
